# map과 flatmap의 차이

- flatmap은 내부의 값을 알아서 더 추출해 준다.
- 내부에 포장된 값도 추출해낼 수 있다.
- map은 Array 내부에 값이 있으면 그 값을 그저 클로저의 코드에서만 실행하고 결과를 다시 Array 컨테이너에 담기만 합니다.
- flatmap은 내부의 옵셔널값을 전부 추출해 준다.

#  클래스와 스트럭트의 차이
- 같은 점
  1. 값을 저장하기 위해 **프로퍼티**를 정의할 수 있습니다.
  2. 기능 실행을 위해 **메서드**를 정의할 수 있습니다.
  3. 서브스크립트 문법을 통해 구조체 또는 클래스가 갖는 값(프로퍼티)에 접근하도록 **서브스크립트**를 정의할 수 있습니다.
  4. 초기화될 때의 상태를 지정하기 위해 **이니셜라이저**를 정의할 수 있습니다.
  5. 초기구현과 더불어 새로운 기능 추가를 위해 **익스텐션**을 통해 확장할 수 있습니다.
  6. 특정 기능을 실행하기 위해 특정 **프로토콜**을 준수할 수 있습니다.
- 다른 점
  1. 구조체는 **상속**할 수 없습니다.
  2. **타입캐스팅**은 클래스의 인스턴스에만 허용됩니다.
  3. **디이니셜라이저**는 클래스의 인스턴스에만 활용할 수 있습니다.
  4. **참조 횟수 계산**은 클래스의 인스턴스에만 적용됩니다.

# obj-c 블럭과 swift 클로저의 차이
- 값 타입 변수를 캡쳐(블럭/클로저 내부에서 사용)하면 클로저에서는 기본적으로 참조타입으로 사용되고 블럭에서는 값 타입으로 사용된다.
- 참조 타입 변수는 둘 다 같다.

# Delegate vs Block vs Notification vs KVO

- 하나의 객체가 다른 객체와 소통은 하지만 묶이기(coupled)는 싫을 때

## Delegate

- Delegate는 보통 Protocol을 정의하여 사용한다.
- Protocol이란 일종의 기능 명세서 같은 것으로 Delegate로 지정된 객체가 해야 하는 메소드들의 원형을 적어 놓는다.
- Delegate 역할을 하려는 객체는 이 Protocol을 따르며 원형만 있던 메소드들의 구현을 한다.
- 이렇게 세팅 후 이전 객체는 어떤 이벤트가 일어났을 시 delegate로 지정한 객체에 알려줄 수 있다.
- 장점
  - 매우 엄격한 Syntax로 인해 프로토콜에 필요한 메소드들이 명확하게 명시됨.
  - 컴파일 시 경고나 에러가 떠서 프로토콜의 구현되지 않은 메소드를 알려줌.
  - 로직의 흐름을 따라가기 쉬움.
  - 프로토콜 메소드로 알려주는 것뿐만이 아니라 정보를 받을 수 있음.
  - 커뮤니케이션 과정을 유지하고 모니터링하는 제 3의 객체(ex: NotificationCenter 같은 외부 객체)가 필요없음.
  - 프로토콜이 컨트롤러의 범위 안에서 정의됨.
- 단점
  - 많은 줄의 코드가 필요.
  - delegate 설정에 nil이 들어가지 않게 주의해야함. 크래시를 일으킬 수 있음.
  - 많은 객체들에게 이벤트를 알려주는 것이 어렵고 비효율적임.(가능은 하지만)

## Block

- 이벤트가 딱 하나일 때 사용하기 좋습니다.
- Completion block 을 사용하는 것이 좋은 예로 NSURLConnection sendAsynchronousRequest:queue:completionHandler:가 있습니다.

## Notification

- Notification Center라는 싱글턴 객체를 통해서 이벤트들의 발생 여부를 옵저버를 등록한 객체들에게 Notification을 post하는 방식으로 사용한다.
- Notification name이라는 key 값을 통해 보내고 받을 수 있다.
- 장점
  - 많은 줄의 코드가 필요없이 쉽게 구현이 가능.
  - 다수의 객체들에게 동시에 이벤트의 발생을 알려줄 수 있음.
  - 과 관련된 정보를 Any? 타입의 object, [AnyHashable: Any]? 타입의 userInfo로 전달할 수 있음.
- 단점
  - key 값으로 Notification의 이름과 userInfo를 서로 맞추기 때문에 컴파일 시 구독이 잘 되고 있는지, 올바르게 userInfo의 value를 받아오는지 체크가 불가능함.
  - 추적이 쉽지 않을 수 있음.
  - Notificaiton post 이후 정보를 받을 수 없음.

## Key Value Observing(KVO)

- KVO는 A 객체에서 B 객체의 프로퍼티가 변화됨을 감지할 수 있는 패턴이다.
- 위의 두 패턴이 주로 Controller와 다른 객체 사이의 관계를 다룬다면 KVO 패턴은 객체와 객체 사이의 관계를 다루는데 적합하다. (물론 다룰수야 있다.)
- 메소드나 다른 액션에서 나타나는 것이 아니라 프로퍼티의 상태에 반응하는 형태이다.
- 장점
  - 두 객체 사이의 정보를 맞춰주는 것이 쉬움.
  - new/old value를 쉽게 얻을 수 있음.
  - key path로 옵저빙하기 때문에 nested objects도 옵저빙이 가능함.
- 단점
  - NSObject를 상속받는 객체에서만 사용이 가능함.
  - dealloc될 때 옵저버를 지워줘야 함.
  - 많은 value를 감지할 때는 많은 조건문이 필요.

#### KVO를 사용하는 경우(프로퍼티 단위의 변화 감지)는 명확하기 때문에 제외하고 Delegation과 Notification을 구분하였다.

#### 그래서 그 글쓴이가 내린 결론은 명확히 프로토콜로 정의되어 있는 Delegation을 웬만하면 사용하자는 것이다.

#### 조금의 노력을 들여서 Delegate로 연결을 하면 코드가 읽기도 쉽고 추적이 쉬워진다는 이유에서이다.

#### 나도 이러한 이유에 동의하지만 여러 오브젝트들이 동시에 어떤 이벤트를 받아 그것을 모두 반영해야 하는 경우, 예를 들어 로그인의 상태가 변하여 많은 뷰들을 업데이트해야 하는 경우에는 Notification이 적절할 것으로 생각된다.

#### 명확하게 답이 나와있지 않은 주제라 무엇이 더 선호되는지 찾고 싶었지만 쉽게 답은 나오지 않았다. 개발을 해가며 상황마다 맞는 방법을 적용하는 것이 가장 옳은 길인 듯 싶다.



참고: https://medium.com/@Alpaca_iOSStudy/delegation-notification-%EA%B7%B8%EB%A6%AC%EA%B3%A0-kvo-82de909bd29



# Swift Memory Management

- 스위프트는 ARC로 메모리 관리를 한다.

### ARC

- 자동 참조 계수(Automatic Reference Counting)
  - 인스턴스가 더 이상 필요없을 때 사용된 메모리를 자동으로 해제해준다.

### 강한 순환 참조

- ARC로 메모리를 관리할 때 발생할 수 있는 문제이다.

- 두 개의 객체가 서로 강한 참조를 하는 경우 발생할 수 있다.
- 해결법
  - 서로 강한 참조를 하는 경우 발생한다면, 둘 중 하나의 강한 참조를 변경해주면 된다.
  - 강한 참조를 약한(weak) 참조 혹은 미소유(unowned) 참조로 변경하면 강한 순환 참조 문제를 해결할 수 있다.
  - 약한 참조는 옵셔널일 때 사용하고, 미소유 참조는 옵셔널이 아닐 때 사용한다.
- 클로저에서의 강한 순환 참조
  - 클래스처럼 클로저는 참조 타입이기 때문에 강한 순환 참조가 발생할 수 있다.
  - 클래스 인스턴스의 프로퍼티에 클로저를 할당 할 때 클로저에 참조를 할당하기 때문에 강한 순환 참조가 발생할 수 있고,
  - 클로져의 본문이 인스턴스를 캡쳐(capture)할 때 클로저가 self를 캡쳐하게 되면서 강한 순환 참조가 발생할 수 있다.
  - 캡쳐(capture)
    - 클로저의 본문에서 인스턴스의 프로퍼티에 접근하거나 인스턴스의 메소드를 호출하는 것을 캡쳐(capture)라고 한다.
  - 해결법
    - 클로저와 클래스 인스턴스 사이에서 강한 순환 참조 해결법은 클로저의 선언부에서 캡쳐 목록(capture list)을 정의하는 것으로 해결할 수 있다.
    - 캡쳐 목록은 클로저 본문에 하나 이상의 참조를 캡쳐할 때 사용하는 규칙을 정의한다.
    - 두 클래스 인스턴스 사이에서의 강한 순환 참조 때 처럼, 강한 참조 대신 약한 참조 혹은 미소유 참조로 선언해서 정의한다.
    - 상황에 따라서 약한 참조와 미소유 참조 중 선택해서 사용한다.